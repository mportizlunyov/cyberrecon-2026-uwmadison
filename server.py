# CyberRECon 2026 UW-Madison
# Developed by Mikhail Ortiz-Lunyov
#
# Setup script to create FastMCP server via Python.
#
# Confirm your sandbox allows file writing!

# This script contains some ChatGPT-generated content.
# Relevant sections will be identified

# Findings:
# - External commands have the same permissions as the user running the server
#   - External commands run as ROOT if server is run as ROOT!
# - External commands cannot 'cd' into a different directory; can still access files outside
# - shell=False disables use of redirects and piping
#   - Inverse is ENABLES, allowing for file writing and piping credentials into sudo promtpts
#     - Via ` echo "*CREDENTIAL*"" | sudo *cmd* `
# - Current implementation is not interactive; timeout of 10 seconds exists


# Import libraries
from fastmcp import FastMCP
import platform
import socket
import subprocess
import sys

mcp = FastMCP("CyberRECon 2026 MCP PoC")
# Define servertype, -1 by default
servertype:int = -1

def print_help():
    print("\t1: PoC #1")
    print("\t2: PoC #2.i")
    print("\t3: PoC #2.ii")
    print("\t4: PoC #2.iii")

@mcp.tool
def greet(name: str) -> str:
    return f"Hello, {name}!"

### ### ### Partially GENERATED BY ChatGPT below

# -------------------------
# Tool 1: Host fingerprint
# -------------------------
@mcp.tool()
def host_info():
    return {
        "hostname": socket.gethostname(),
        "ip": socket.gethostbyname(socket.gethostname()),
        "os": platform.system(),
        "release": platform.release(),
        "machine": platform.machine()
    }

# -------------------------
# Tool 2: Active connections
# -------------------------
@mcp.tool()
def active_connections():
    result = subprocess.run(
        ["netstat", "-ano"],
        capture_output=True,
        text=True
    )
    return result.stdout

# -------------------------
# Tool 3: Restricted shell
# -------------------------
ALLOWED_COMMANDS = {
    "whoami": ["whoami"],
    "ipconfig": ["ipconfig"],
    "arp": ["arp", "-a"],
}

@mcp.tool()
def run_command(command:str):

    ### Developer modification (Non-ChatGPT)

    # Dangers:
    # - Using shell=true
    # - Using input="*" for interactive
    # - Using command.split("  ") [two spaces]
    # - Using something more robust than command.split()

    # Full Shell access
    ## Most dangerous version, giving full shell access
    if servertype == 1 or servertype == 4:
        result = subprocess.run(
            command,
            shell=True, # <- Danger
            capture_output=False,
            stdout=subprocess.PIPE,  # Added for smoother output
            stderr=subprocess.STDOUT,# Added for smoother output
            text=True,
            timeout=10 # 10 seconds
        )
    # Individual commands
    ## Less dangerous but still risky
    elif servertype == 3:
        result = subprocess.run(
            command.split(),
            capture_output=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=10
        )
    # Restricted list of commands
    ## Least dangerous, restricted shell
    else:
        if command not in ALLOWED_COMMANDS:
            return "Command not allowed"
        result = subprocess.run(
            ALLOWED_COMMANDS[command],
            capture_output=True,
            text=True
        )

    ### End Developer modification (Non-ChatGPT)

    return result.stdout

### ### ### END Partial ChatGPT content

# Main method
if __name__ == "__main__":
    # Check for argument length
    if len(sys.argv) < 2:
        print("Not enough arguments provided")
        print_help()
        quit(1)
    elif len(sys.argv) > 2:
        print("Too many   arguments provided")
        print_help()
        quit(1)
    else:
        # Normal amount provided
        ## PoC #1 (Stdio)
        if sys.argv[1] == "1":
            servertype = 1
            mcp.run() 
        ## PoC #2 (HTTP, Restricted commands)
        elif sys.argv[1] == "2":
            servertype = 2
            mcp.run(transport="http", port=8000)
        ## PoC #3 (HTTP, Un-Restricted commands)
        elif sys.argv[1] == "3":
            servertype = 3
            mcp.run(transport="http", port=8000)
        ## PoC #4 (HTTP, FULL Shell access)
        elif sys.argv[1] == "4":
            servertype = 4
            mcp.run(transport="http", port=8000)
        ## Bad option
        else:
            print("Improper argument given")
            print_help()
            quit(1)